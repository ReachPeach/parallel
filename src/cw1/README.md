# Parallel Quicksort

Нужно реализовать quicksort.
От Вас требуется написать последовательную версию алгоритма (seq) и параллельную версию (par). Взять случайный массив из 10^8 элементов и отсортировать. (Усреднить по 5 запускам) Сравнить время работы par на 4 процессах и seq на одном процессе - у Вас должно быть раза в 3 быстрее.  (Если будет медленнее, то выставление баллов оставляется на наше усмотрение.)
Также нужно сопроводить тестами на корректность работы алгоритма.

## Структура

Все реализовано в cw1.QuickSort.kt

Последовательной реализации соответствуют функция seqQuicksort; она полагается на функции partition и quicksortSequential

Параллельной реализации соответствует функция parQuicksort; она полагается на ForkJoinPool и ParQuicksortTask

В мейне сначала производится ассерт-проверка на то, что реализации реально сортят массив

Затем 5 раз прогоняется на таргет массиве запуск сортировки для вычисления времени

---

## Обзор результатов

Результаты по запускам локально:

Sequential sorting mean time: **15653ms**

Parallel sorting mean time: **5712ms**

---

### Вывод
- Ускорение в **2.74** раза

### Комментарии

#### Про реализацию quicksort-а

Ну был разговор что нужно брать нормальный алгос с partition-ами; на тупом алгосе работает долго и грустно (я проверил)

#### Про параллельную реализацию

Решил использовать ForkJoinPool для распараллеливания, его можно сконфигурировать по количеству процессов (использую 4)

Для того, чтобы работать с ForkJoinPool, нужно определить класс таски, которую он будет обрабатывать

#### Про реализацию распараллеливаемой таски

Понятно, что мы хотим что-то типа fork2join. 
Идейно было предположение, что можно делать один форк но вторую ветку добивать в этом же процессе.
На практике на производительность по времени не повлияло, но комменты в этом месте оставил (просто остались)

#### Про переход к последовательному от параллельного

В параллельной реализации использовал хак, что при малом промежутке выгодно вызвать последовательный алгос. 
Вопрос только в том, как правильно подобрать границу. Прогнал тесты, пришел к тому, что оптимально это порядок 256 размер границы


#### Зачем два partition

На самом деле не за чем, просто один локальный для каждой таски просто потому что почему бы и нет. Задротский (нечитаемый) swap внутри - в подарок

---

# Parallel Quicksort

Нужно реализовать quicksort.
От Вас требуется написать последовательную версию алгоритма (seq) и параллельную версию (par). Взять случайный массив из
10^8 элементов и отсортировать. (Усреднить по 5 запускам) Сравнить время работы par на 4 процессах и seq на одном
процессе - у Вас должно быть раза в 3 быстрее.  (Если будет медленнее, то выставление баллов оставляется на наше
усмотрение.)
Также нужно сопроводить тестами на корректность работы алгоритма.

## Структура

Все реализовано в cw1.QuickSort.kt

Последовательной реализации соответствуют функция seqQuicksort; она полагается на функции partition и
quicksortSequential

Параллельной реализации соответствует функция parQuicksort; она полагается на ForkJoinPool и ParQuicksortTask

В мейне сначала производится ассерт-проверка на то, что реализации реально сортят массив

Затем 5 раз прогоняется на таргет массиве запуск сортировки для вычисления времени

---

## Обзор результатов

Результаты по запускам локально:

Sequential sorting mean time: **15653ms**

Parallel sorting mean time: **5712ms**

Вот в дополнении более подробная табличка по другому локальному запуску

|                             | 1 запуск, ms | 2 запуск, ms | 3 запуск, ms | 4 запуск, ms | 5 запуск, ms | Среднее время, ms |
|-----------------------------|--------------|--------------|--------------|--------------|--------------|-------------------|
| Последовательная реализация | 23337        | 26308        | 26687        | 24714        | 24145        | 25038             |
| Параллельная реализация     | 9023         | 9626         | 8864         | 8499         | 7639         | 8730              |

При таких рассчетах ускорение уже в 2,868 раза

---

### Вывод

- Ускорение в **2.74** раза

### Комментарии

#### Про реализацию quicksort-а

Ну был разговор что нужно брать нормальный алгос с partition-ами; на тупом алгосе работает долго и грустно (я проверил)

#### Про параллельную реализацию

Решил использовать ForkJoinPool для распараллеливания, его можно сконфигурировать по количеству процессов (использую 4)

Для того, чтобы работать с ForkJoinPool, нужно определить класс таски, которую он будет обрабатывать

#### Про реализацию распараллеливаемой таски

Понятно, что мы хотим что-то типа fork2join.
Идейно было предположение, что можно делать один форк но вторую ветку добивать в этом же процессе.
На практике на производительность по времени не повлияло, но комменты в этом месте оставил (просто остались)

#### Про переход к последовательному от параллельного

В параллельной реализации использовал хак, что при малом промежутке выгодно вызвать последовательный алгос.
Вопрос только в том, как правильно подобрать границу. Прогнал тесты, пришел к тому, что оптимально это порядок 256
размер границы

Вот табличка по запускам для разных размеров границ (запускалось на 10^8 элементов, усреднялось по 10 запускам):

| Значение границы | 1 запуск | 2 запуск |
|------------------|----------|----------|
| 4                | 7153     | 9251     |
| 8                | 8911     | 7762     |
| 16               | 7941     | 7663     |
| 32               | 7390     | 7732     |
| 64               | 6852     | 7816     |
| 128              | 6646     | 7247     |
| 256              | 5823     | 6996     |
| 512              | 5700     | 7134     |
| 1024             | 5863     | 7555     |
| 2048             | 5763     | 7111     |
| 4096             | 5795     | 7081     |
| 8192             | 5986     | 7014     |

#### Зачем два partition

На самом деле не за чем, просто один локальный для каждой таски просто потому что почему бы и нет. Задротский (
нечитаемый) swap внутри - в подарок

---
